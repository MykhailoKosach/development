<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Deck-Style Building Passport Gallery</title>
  <style>
    :root{
      --side-margin: 10vw; /* 10% on each side */
      --container-w: calc(100vw - (2 * var(--side-margin))); /* 80% */
      --radius: 20px;
      --shadow: 0 10px 30px rgba(0,0,0,.25);
      --text-bg: rgba(0,0,0,.45);
      --accent: #06b6d4; /* cyan-500 */
      --arrow-size: clamp(40px, 5vw, 60px);
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body{
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: #0b1020;
      color: #e8eefc;
    }

    .gallery-wrap{
      position: relative;
      padding: clamp(16px, 3vh, 32px) 0 64px;
      min-height: 70vh;
    }

    /* Container honors 10% margins on both sides (80% remaining) */
    .gallery{
      width: var(--container-w);
      margin-left: var(--side-margin);
      position: relative;
      height: clamp(380px, 60vh, 700px);
      overflow: hidden; /* ensure no horizontal scroll */
    }

    /* Slides are absolutely positioned; we compute layout in JS */
    .slide{
      position: absolute;
      top: 0;
      height: 100%;
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow: hidden;
      transition: left .5s cubic-bezier(.2,.8,.2,1),
                  width .5s cubic-bezier(.2,.8,.2,1),
                  transform .5s cubic-bezier(.2,.8,.2,1),
                  filter .5s cubic-bezier(.2,.8,.2,1),
                  opacity .5s ease;
      background: #111827;
    }

    .slide img{
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .slide .overlay{
      position: absolute;
      inset: 0;
      background: linear-gradient(to top, rgba(0,0,0,.65) 10%, rgba(0,0,0,.25) 60%, rgba(0,0,0,0) 100%);
      display: flex;
      align-items: flex-end;
      padding: 20px;
      color: #fff;
    }

    .passport{
      background: var(--text-bg);
      backdrop-filter: blur(4px);
      padding: 14px 16px;
      border-radius: 14px;
      width: min(92%, 560px);
    }
    .passport h3{
      margin: 0 0 6px;
      font-size: clamp(18px, 2.2vw, 28px);
      letter-spacing: .2px;
    }
    .passport .meta{
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px 16px;
      font-size: clamp(12px, 1.3vw, 14px);
      opacity: .95;
    }
    .passport .meta div{ white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .passport .tag{
      display: inline-block;
      margin-top: 8px;
      font-size: .85em;
      padding: 6px 10px;
      background: rgba(6,182,212,.18);
      border: 1px solid rgba(6,182,212,.55);
      border-radius: 999px;
      letter-spacing: .2px;
    }

    /* Controls */
    .arrow{
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      width: var(--arrow-size);
      height: var(--arrow-size);
      border-radius: 50%;
      background: rgba(255,255,255,.1);
      border: 1px solid rgba(255,255,255,.25);
      display: grid;
      place-items: center;
      cursor: pointer;
      user-select: none;
      backdrop-filter: blur(4px);
      transition: background .2s ease, transform .15s ease;
      z-index: 50;
    }
    .arrow:hover{ background: rgba(255,255,255,.18); }
    .arrow:active{ transform: translateY(-50%) scale(.96); }

    .arrow svg{ width: 55%; height: 55%; fill: #fff; }

    .arrow.prev{ left: calc(var(--side-margin) - var(--arrow-size) - 10px); }
    .arrow.next{ right: calc(var(--side-margin) - var(--arrow-size) - 10px); }

    /* Indicators (optional) */
    .dots{
      position: absolute;
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%);
      display: flex; gap: 8px;
    }
    .dot{
      width: 8px; height: 8px; border-radius: 50%;
      background: rgba(255,255,255,.25);
      transition: transform .2s ease, background .2s ease;
    }
    .dot.active{ background: var(--accent); transform: scale(1.3); }

    /* Accessibility helpers for reduced motion */
    @media (prefers-reduced-motion: reduce) {
      .slide{ transition: none; }
      .arrow{ transition: none; }
      .dot{ transition: none; }
    }

    /* Responsive tweaks */
    @media (max-width: 900px){
      .gallery{ height: 58vh; }
    }
    @media (max-width: 700px){
      .gallery{ height: 56vh; }
      .arrow.prev{ left: 8px; }
      .arrow.next{ right: 8px; }
    }
    @media (max-width: 520px){
      .passport{ width: 96%; }
      .passport .meta{ grid-template-columns: 1fr; }
    }
    @media (max-width: 600px){
      /* Move arrows next to dots on mobile */
      .arrow{
        top: auto;
        bottom: 0;
        width: 40px;
        height: 40px;
      }
      .arrow:active{ transform: scale(.96); }
      .arrow.prev{ 
        left: calc(50% - 70px);
        transform: translateX(-100%);
      }
      .arrow.next{ 
        right: calc(50% - 70px);
        left: auto;
        transform: translateX(100%);
      }
    }
  </style>
</head>
<body>
  <div class="gallery-wrap">
    <!-- Arrows are outside the 80% container (excluded from width) -->
    <button class="arrow prev" aria-label="Previous" title="Previous" data-dir="-1">
      <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M15.41 7.41 14 6l-6 6 6 6 1.41-1.41L10.83 12z"/></svg>
    </button>

    <div class="gallery" id="gallery" aria-roledescription="carousel" aria-label="Building passports">
      <!-- Slides injected by JS -->
    </div>

    <button class="arrow next" aria-label="Next" title="Next" data-dir="1">
      <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M8.59 16.59 10 18l6-6-6-6-1.41 1.41L13.17 12z"/></svg>
    </button>

    <div class="dots" id="dots" aria-hidden="true"></div>
  </div>

  <script>
    const data = [
      { img: 'https://picsum.photos/id/1011/1600/1000', name: 'Atria Tower', year: '1998', city: 'Rotterdam', architect: 'MVRDV', height: '180 m', function: 'Mixed-use', note: 'LEED Gold candidate' },
      { img: 'https://picsum.photos/id/1003/1600/1000', name: 'Harbor View', year: '2006', city: 'Copenhagen', architect: 'BIG (Bjarke Ingels Group)', height: '92 m', function: 'Residential', note: 'Green roof terraces' },
      { img: 'https://picsum.photos/id/1005/1600/1000', name: 'Glassworks 12', year: '2015', city: 'Dublin', architect: 'RKD Architects', height: '64 m', function: 'Office', note: 'Double-skin faÃ§ade' },
      { img: 'https://picsum.photos/id/1016/1600/1000', name: 'Marina Gate', year: '2019', city: 'Dubai', architect: 'AECOM', height: '206 m', function: 'Residential', note: 'Podium retail' },
      { img: 'https://picsum.photos/id/1025/1600/1000', name: 'Cedar Court', year: '2022', city: 'Vancouver', architect: 'Perkins&Will', height: '55 m', function: 'Timber hybrid', note: 'Mass timber cores' }
    ];

    const gallery = document.getElementById('gallery');
    const dots = document.getElementById('dots');

    // Build slides & dots
    data.forEach((b, i) => {
      const card = document.createElement('article');
      card.className = 'slide';
      card.setAttribute('role', 'group');
      card.setAttribute('aria-roledescription', 'slide');
      card.setAttribute('aria-label', `${i+1} of ${data.length}: ${b.name}`);
      card.innerHTML = `
        <img src="${b.img}" alt="${b.name} in ${b.city}" loading="lazy"/>
        <div class="overlay">
          <div class="passport">
            <h3>${b.name}</h3>
            <div class="meta">
              <div><strong>Year:</strong> ${b.year}</div>
              <div><strong>City:</strong> ${b.city}</div>
              <div><strong>Architect:</strong> ${b.architect}</div>
              <div><strong>Height:</strong> ${b.height}</div>
              <div><strong>Use:</strong> ${b.function}</div>
              <div><strong>Notes:</strong> ${b.note}</div>
            </div>
            <span class="tag" aria-hidden="true">Building passport</span>
          </div>
        </div>`;
      gallery.appendChild(card);
      const d = document.createElement('span');
      d.className = 'dot' + (i === 0 ? ' active' : '');
      d.dataset.i = i;
      dots.appendChild(d);
    });

    const slides = [...document.querySelectorAll('.slide')];
    let order = slides.map((_, i) => i); // infinite deck order; active is always order[0]
    const parallax = { t: 0 }; // -0.5..0.5 range

    function layout(){
      const w = gallery.clientWidth;
      const n = slides.length;
      if (!n) return;

      if (w < 600){
        // --- Compact mobile layout: centered active with tiny side peeks + parallax ---
        const peek = Math.max(20, Math.min(30, w * 0.06)); // 20-30px visible on sides
        const activeW = Math.max(220, Math.min(w - 2 * peek, 500));
        const center = (w - activeW) / 2;
        const prevIdx = order[n - 1];
        const nextIdx = order[1];

        slides.forEach((el, i) => {
          const pos = order.indexOf(i);
          el.style.pointerEvents = 'none';
          if (pos === 0){
            // Active: perfectly centered; subtle parallax
            const dx = parallax.t * 8;
            el.style.left = `${center + dx}px`;
            el.style.width = `${activeW}px`;
            el.style.transform = 'scale(1)';
            el.style.filter = 'grayscale(0) saturate(1)';
            el.style.zIndex = 100;
            el.style.opacity = 1;
            el.style.pointerEvents = 'auto';
          } else if (i === nextIdx){
            // Next: tiny peek on the right, moves more for parallax
            const dx = parallax.t * 18;
            el.style.left = `${w - peek + dx}px`;
            el.style.width = `${activeW}px`;
            el.style.transform = 'scale(0.96)';
            el.style.filter = 'grayscale(1) brightness(.84)';
            el.style.zIndex = 90;
            el.style.opacity = 1;
            el.style.pointerEvents = 'auto';
          } else if (i === prevIdx){
            // Previous: tiny peek on the left
            const dx = -parallax.t * 18;
            el.style.left = `${-activeW + peek + dx}px`;
            el.style.width = `${activeW}px`;
            el.style.transform = 'scale(0.96)';
            el.style.filter = 'grayscale(1) brightness(.84)';
            el.style.zIndex = 90;
            el.style.opacity = 1;
            el.style.pointerEvents = 'auto';
          } else {
            // Hide all other cards in mobile mode
            el.style.left = `${center}px`;
            el.style.width = `${activeW}px`;
            el.style.transform = 'scale(0.9)';
            el.style.filter = 'grayscale(1) brightness(.6)';
            el.style.zIndex = 1;
            el.style.opacity = 0;
          }
        });

        // Update dots by original index
        [...dots.children].forEach((d, idx) => d.classList.toggle('active', order[0] === idx));
        return; // --- end mobile branch ---
      }

      // --- Deck layout for >=600px ---
      // Responsive main card ratio (smaller on phones to fit full cascade)
      let r = w <= 900 ? 0.66 : 0.7;
      let activeW = Math.min(Math.max(260, w * r), w - 12);

      // Where stacked cards begin behind the active's right edge
      const peek = Math.max(56, Math.min(160, w * 0.12));
      let stackStart = activeW - peek;

      const nStack = Math.max(0, slides.length - 1);
      // Spacing
      let minStep = Math.max(12, Math.min(26, w * 0.03));
      let maxStep = Math.max(28, Math.min(56, w * 0.06));
      let minStackW = Math.max(140, Math.min(260, w * 0.28));

      // Choose step so that the last stacked card ends at the container's right edge
      let s = nStack > 1 ? (w - stackStart - minStackW) / (nStack - 1) : maxStep;
      s = Math.max(minStep, Math.min(maxStep, isFinite(s) ? s : maxStep));
      let stackW = w - stackStart - (nStack - 1) * s;

      if (stackW < minStackW) {
        const deficit = (minStackW - stackW);
        activeW = Math.max(220, activeW - deficit - 8);
        stackStart = activeW - peek;
        s = nStack > 1 ? (w - stackStart - minStackW) / (nStack - 1) : maxStep;
        s = Math.max(minStep, Math.min(maxStep, isFinite(s) ? s : maxStep));
        stackW = w - stackStart - (nStack - 1) * s;
      }

      stackW = Math.max(minStackW, Math.min(stackW, Math.max(200, activeW * 0.9)));

      slides.forEach((el, i) => {
        const pos = order.indexOf(i); // 0 is active, >=1 stacked
        el.style.pointerEvents = 'auto';
        if (pos === 0){
          el.style.left = `0px`;
          el.style.width = `${activeW}px`;
          el.style.transform = 'scale(1)';
          el.style.filter = 'grayscale(0) saturate(1)';
          el.style.zIndex = 100;
          el.style.opacity = 1;
        } else {
          const k = pos - 1;
          const left = stackStart + k * s;
          const scale = Math.max(0.82, 0.96 - k * 0.04);
          el.style.left = `${left}px`;
          el.style.width = `${stackW}px`;
          el.style.transform = `scale(${scale})`;
          el.style.filter = 'grayscale(1) brightness(.78)';
          el.style.zIndex = 90 - k;
          el.style.opacity = 1;
        }
      });

      [...dots.children].forEach((d, idx) => d.classList.toggle('active', order[0] === idx));
    }

    function move(dir){
      if (dir > 0) {
        order.push(order.shift()); // next: first to end
      } else {
        order.unshift(order.pop()); // prev: last to front
      }
      layout();
    }

    // Arrow controls
    document.querySelectorAll('.arrow').forEach(btn => btn.addEventListener('click', () => move(parseInt(btn.dataset.dir, 10))));

    // Keyboard controls
    window.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowRight') move(1);
      if (e.key === 'ArrowLeft') move(-1);
    });

    // Click to bring a card to the top (rotate deck)
    slides.forEach((el, i) => el.addEventListener('click', () => {
      const pos = order.indexOf(i);
      if (pos <= 0) return;
      for (let t = 0; t < pos; t++) order.push(order.shift());
      layout();
    }));

    // Dot navigation (rotate to selected original index)
    [...dots.children].forEach(d => d.addEventListener('click', () => {
      const idx = parseInt(d.dataset.i, 10);
      const pos = order.indexOf(idx);
      for (let t = 0; t < pos; t++) order.push(order.shift());
      layout();
    }));

    // Pointer-based parallax on mobile layout
    gallery.addEventListener('pointermove', (e) => {
      const w = gallery.clientWidth;
      if (w >= 600) return; // only on mobile layout
      const rect = gallery.getBoundingClientRect();
      const x = (e.clientX - rect.left) / Math.max(1, w);
      parallax.t = Math.max(-0.5, Math.min(0.5, x - 0.5));
      layout();
    });
    gallery.addEventListener('pointerleave', () => { parallax.t = 0; layout(); });

    // Resize throttle
    let t; window.addEventListener('resize', () => { clearTimeout(t); t = setTimeout(() => { parallax.t = 0; layout(); }, 80); });

    // Initial
    layout();
  </script>
</body>
</html>
