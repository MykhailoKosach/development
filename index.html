<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Mission Animation (Final SVG Version)</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    overflow: hidden;
    font-family: "Arial", sans-serif;
    background: #fff;
    color: #111;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }
  
  body:focus {
    outline: none;
  }

  .container {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    text-align: center;
  }

  .mission-text {
    font-size: 3.5rem;
    font-weight: 700;
    line-height: 1.6;
    width: 80%;
    max-width: 80%;
    text-align: left;
  }

  .phrase {
    display: inline-block;
    position: relative;
    padding: 6px 10px;
    margin: 6px 8px;
    cursor: default;
    user-select: none;
    opacity: 0;
    transform: translateY(20px);
    transition: opacity 0.6s ease, transform 0.6s ease;
  }

  .phrase.loaded {
    opacity: 1;
    transform: translateY(0);
  }

  /* SVG рамка */
  .border-svg {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .phrase.active .border-svg {
    opacity: 1;
  }

  .border-path {
    fill: none;
    stroke: #ff0000;
    stroke-width: 3;
    stroke-dasharray: 1000;
    stroke-dashoffset: 1000;
    transition: stroke-dashoffset 1s ease;
    will-change: stroke-dashoffset;
  }

  .phrase.active .border-path {
    stroke-dashoffset: 0;
  }

  /* Стрілки */
  .arrow-svg {
    position: fixed;
    pointer-events: none;
    z-index: 10;
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .phrase.active .arrow-svg {
    opacity: 1;
  }

  .arrow-path {
    stroke: #000;
    stroke-width: 2;
    fill: none;
    stroke-dasharray: 1000;
    stroke-dashoffset: 1000;
    transition: stroke-dashoffset 1.2s ease;
    will-change: stroke-dashoffset;
  }

  .phrase.active .arrow-path {
    stroke-dashoffset: 0;
  }

  /* Описи */
  .desc {
    position: absolute;
    max-width: 400px;
    font-size: 0.85rem;
    line-height: 1.4;
    opacity: 0;
    transition: opacity 1s ease;
    will-change: opacity;
    pointer-events: none;
  }

  .desc.visible {
    opacity: 1;
  }

  /* Розташування описів - directly above/below phrases */
  .desc-1 { 
    top: 10%; 
    left: 10%; 
    text-align: left; 
  }
  .desc-2 { 
    top: 20%; 
    left: 20%; 
    text-align: left; 
  }
  .desc-3 { 
    top: 60%; 
    left: 65%; 
    text-align: left; 
  }
  .desc-4 { 
    bottom: 10%; 
    left: 10%; 
    text-align: left; 
  }
</style>
</head>
<body>

<div class="container">
  <div class="mission-text">
    <span class="phrase" data-index="1">
      Ми
      <svg class="border-svg">
        <rect class="border-path" x="0" y="0" width="100%" height="100%" rx="8" ry="8"></rect>
      </svg>
    </span>
    <span class="phrase" data-index="2">
      будуємо
      <svg class="border-svg">
        <rect class="border-path" x="0" y="0" width="100%" height="100%" rx="8" ry="8"></rect>
      </svg>
    </span>
    <span class="phrase" data-index="3">
      більше ніж склади,
      <svg class="border-svg">
        <rect class="border-path" x="0" y="0" width="100%" height="100%" rx="8" ry="8"></rect>
      </svg>
    </span>
    <br>
    <span class="phrase" data-index="4">
      ми будуємо можливості
      <svg class="border-svg">
        <rect class="border-path" x="0" y="0" width="100%" height="100%" rx="8" ry="8"></rect>
      </svg>
    </span>
  </div>

  <!-- ОПИСИ -->
  <div class="desc desc-1" id="desc1">
    Команда ProTec Development: архітектори, інженери, проектувальники, девелопери.
  </div>
  <div class="desc desc-2" id="desc2">
    Повний цикл — від пошуку ділянки до управління об’єктом.
  </div>
  <div class="desc desc-3" id="desc3">
    Не лише про фізичне зведення. Це про створення концепції, розробку індивідуального проєкту, контроль якості.
  </div>
  <div class="desc desc-4" id="desc4">
    Ми будуємо можливості для розвитку бізнесу, створюємо простір для логістики, роботи та масштабування.
  </div>

  <!-- Dynamic arrow SVG -->
  <svg id="arrow-container" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10;">
    <path id="arrow-path-1" class="arrow-path" d="" stroke="#000" stroke-width="2" fill="none" style="opacity: 0; transition: opacity 0.3s ease;" />
    <path id="arrow-path-2" class="arrow-path" d="" stroke="#000" stroke-width="2" fill="none" style="opacity: 0; transition: opacity 0.3s ease;" />
    <path id="arrow-path-3" class="arrow-path" d="" stroke="#000" stroke-width="2" fill="none" style="opacity: 0; transition: opacity 0.3s ease;" />
    <path id="arrow-path-4" class="arrow-path" d="" stroke="#000" stroke-width="2" fill="none" style="opacity: 0; transition: opacity 0.3s ease;" />
  </svg>
</div>

<script>
  // ==================== STATE MANAGEMENT ====================
  const phrases = document.querySelectorAll('.phrase');
  const descriptions = document.querySelectorAll('.desc');
  const arrowContainer = document.getElementById('arrow-container');
  
  let currentIndex = -1; // Start at -1 so first scroll goes to index 0
  let isAnimating = false;
  let touchStartY = 0;
  let touchMoved = false;
  let isInitialized = false; // Track if initial animation is done

  // ==================== CORE FUNCTIONS ====================
  
  /**
   * Animate phrases appearing word by word on page load
   */
  function initializePageLoad() {
    phrases.forEach((phrase, index) => {
      setTimeout(() => {
        phrase.classList.add('loaded');
      }, index * 200); // 200ms delay between each word
    });
    
    // Mark as initialized after all phrases have loaded
    setTimeout(() => {
      isInitialized = true;
    }, phrases.length * 200 + 600);
  }
  
  /**
   * Calculate and draw arrow from phrase to description
   * @param {number} index - The index of the phrase
   */
  function drawArrow(index) {
    const phrase = phrases[index];
    const description = document.getElementById(`desc${index + 1}`);
    const arrowPath = document.getElementById(`arrow-path-${index + 1}`);
    
    if (!phrase || !description || !arrowPath) {
      return;
    }

    const phraseRect = phrase.getBoundingClientRect();
    const descRect = description.getBoundingClientRect();

    // Use phrase center X for vertical line
    const centerX = phraseRect.left + phraseRect.width / 2;
    
    // For phrase 3 (index 2), offset to the right
    const lineX = (index === 2) 
      ? centerX + (phraseRect.width * 0.15)  // 15% to the right for phrase 3
      : centerX;  // Center for all others
    
    let startY, endY;
    
    // Check if description is above or below the phrase
    const descIsBelow = descRect.top > phraseRect.bottom;
    
    if (descIsBelow) {
      // Description is below phrase: arrow from bottom going down
      startY = phraseRect.bottom;
      endY = descRect.top;
    } else {
      // Description is above phrase: arrow from top going up
      startY = phraseRect.top;
      endY = descRect.bottom;
    }

    // Create perfectly vertical line (same X coordinate for start and end)
    const pathData = `M ${lineX} ${startY} L ${lineX} ${endY}`;
    
    // Calculate path length for animation
    arrowPath.setAttribute('d', pathData);
    const pathLength = arrowPath.getTotalLength();
    arrowPath.style.strokeDasharray = pathLength;
    arrowPath.style.strokeDashoffset = pathLength;

    // Show arrow
    arrowPath.style.opacity = '1';
    
    // Animate arrow after a brief delay
    setTimeout(() => {
      arrowPath.style.strokeDashoffset = '0';
    }, 50);
  }

  /**
   * Activate a specific phrase and show its description
   * @param {number} index - The index of the phrase to activate
   */
  function activatePhrase(index) {
    // Reset all phrases - hide borders
    phrases.forEach((phrase, i) => {
      phrase.classList.remove('active');
      const borderPath = phrase.querySelector('.border-path');
      if (borderPath) {
        const pathLength = borderPath.getTotalLength();
        borderPath.style.strokeDasharray = pathLength;
        borderPath.style.strokeDashoffset = pathLength;
      }
    });
    
    // Activate current phrase
    phrases[index].classList.add('active');
    
    // Animate the border for active phrase
    const borderPath = phrases[index].querySelector('.border-path');
    if (borderPath) {
      const pathLength = borderPath.getTotalLength();
      borderPath.style.strokeDasharray = pathLength;
      borderPath.style.strokeDashoffset = pathLength;
      
      // Trigger animation with a small delay
      setTimeout(() => {
        borderPath.style.strokeDashoffset = '0';
      }, 50);
    }
    
    // Show corresponding description (keep previous descriptions visible)
    const description = document.getElementById(`desc${index + 1}`);
    if (description) {
      description.classList.add('visible');
    }

    // Draw arrow from phrase to description
    drawArrow(index);
  }

  /**
   * Navigate to the next or previous phrase
   * @param {number} direction - Positive for next, negative for previous
   */
  function navigatePhrase(direction) {
    if (isAnimating) return;
    
    // Don't allow navigation until initial animation is complete
    if (!isInitialized) return;
    
    const previousIndex = currentIndex;
    
    // Calculate new index
    if (direction > 0 && currentIndex < phrases.length - 1) {
      currentIndex++;
    } else if (direction < 0 && currentIndex > 0) {
      currentIndex--;
    }
    
    // Only animate if index changed
    if (previousIndex !== currentIndex) {
      isAnimating = true;
      activatePhrase(currentIndex);
      
      // Release animation lock after transition completes
      setTimeout(() => {
        isAnimating = false;
      }, 1200);
    }
  }

  // ==================== EVENT HANDLERS ====================
  
  /**
   * Handle mouse wheel scrolling
   */
  function handleWheel(event) {
    event.preventDefault();
    navigatePhrase(event.deltaY);
  }

  /**
   * Handle touch start
   */
  function handleTouchStart(event) {
    touchStartY = event.touches[0].clientY;
    touchMoved = false;
  }

  /**
   * Handle touch move
   */
  function handleTouchMove(event) {
    if (isAnimating) return;
    
    const touchCurrentY = event.touches[0].clientY;
    const touchDelta = touchStartY - touchCurrentY;
    
    // Threshold to prevent accidental triggers
    if (Math.abs(touchDelta) > 50 && !touchMoved) {
      touchMoved = true;
      event.preventDefault();
      navigatePhrase(touchDelta);
    }
  }

  /**
   * Handle keyboard navigation
   */
  function handleKeyboard(event) {
    // Don't allow keyboard navigation until initialized
    if (!isInitialized) return;
    
    switch(event.key) {
      case 'ArrowDown':
      case 'ArrowRight':
      case 'PageDown':
        event.preventDefault();
        navigatePhrase(1);
        break;
      case 'ArrowUp':
      case 'ArrowLeft':
      case 'PageUp':
        event.preventDefault();
        navigatePhrase(-1);
        break;
      case 'Home':
        event.preventDefault();
        if (currentIndex !== 0) {
          currentIndex = 0;
          activatePhrase(currentIndex);
        }
        break;
      case 'End':
        event.preventDefault();
        if (currentIndex !== phrases.length - 1) {
          currentIndex = phrases.length - 1;
          activatePhrase(currentIndex);
        }
        break;
    }
  }

  // ==================== EVENT LISTENERS ====================
  
  window.addEventListener('wheel', handleWheel, { passive: false });
  window.addEventListener('touchstart', handleTouchStart, { passive: true });
  window.addEventListener('touchmove', handleTouchMove, { passive: false });
  window.addEventListener('keydown', handleKeyboard);
  
  // Redraw all visible arrows on window resize
  window.addEventListener('resize', () => {
    for (let i = 0; i <= currentIndex; i++) {
      drawArrow(i);
    }
  });

  // ==================== INITIALIZATION ====================
  
  // Start with word-by-word animation on page load
  initializePageLoad();
  
  // Ensure body is focusable for keyboard navigation
  document.body.setAttribute('tabindex', '0');
  document.body.focus();
</script>

</body>
</html>
